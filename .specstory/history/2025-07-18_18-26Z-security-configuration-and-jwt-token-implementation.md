<!-- Generated by SpecStory -->

# Security configuration and JWT token implementation (2025-07-18 18:26Z)

_**User**_

1. SecurityConfig에서 addFilterBefore 에 사용자가 정의한 Filter를 넣어주는데, 이때는 DI를 사용할 필요없니?

2. JwtTokenProvider에서 validateToken, getUsernameFromToken 부분을 채워줘

---

_**Assistant**_

아래는 질문에 대한 답변입니다.

1. SecurityConfig에서 addFilterBefore에 사용자가 정의한 Filter를 넣어줄 때 DI를 사용할 필요가 없는가?

아닙니다. DI(Dependency Injection)를 사용하는 것이 일반적이고 권장됩니다.  
Spring Security의 SecurityFilterChain을 설정할 때, 커스텀 필터(JwtAuthenticationFilter 등)를 addFilterBefore로 추가할 때 해당 필터를 DI로 주입받는 것이 좋습니다.  
이렇게 하면 해당 필터가 의존하는 서비스나 컴포넌트(JwtTokenProvider, UserDetailsService 등)도 Spring이 관리하게 되어 테스트, 유지보수, 확장성 측면에서 유리합니다.

즉, 아래와 같이 DI를 통해 필터를 주입받는 것이 맞습니다.

```kotlin
@Bean
fun filterChain(
    http: HttpSecurity,
    jwtAuthenticationFilter: JwtAuthenticationFilter, // DI로 주입
): SecurityFilterChain = 
    http
        // ... 생략 ...
        .addFilterBefore(jwtAuthenticationFilter, UsernamePasswordAuthenticationFilter::class.java)
        // ... 생략 ...
        .build()
```

jwtAuthenticationFilter는 @Component로 등록되어 있으므로, DI로 주입받는 것이 맞습니다.

---

2. JwtTokenProvider에서 validateToken, getUsernameFromToken 부분 구현

아래는 JwtTokenProvider의 validateToken, getUsernameFromToken 메서드의 예시 구현입니다.  
(코드 내에 필요한 부분만 발췌하여 설명합니다. 실제로는 secret key를 환경변수 등에서 받아와야 하며, 예시에서는 간단히 String key를 사용합니다.)

```kotlin
import io.jsonwebtoken.Claims
import io.jsonwebtoken.Jwts
import io.jsonwebtoken.security.Keys
import org.springframework.stereotype.Service
import java.util.*

@Service
class JwtTokenProvider {
    private val secretKey = "your-256-bit-secret-your-256-bit-secret" // 32byte 이상 필요
    private val key = Keys.hmacShaKeyFor(secretKey.toByteArray())

    fun issueToken(subject: String): String {
        return Jwts.builder()
            .setSubject(subject)
            .setIssuer("ian")
            .setIssuedAt(Date())
            .setExpiration(Date(System.currentTimeMillis() + 3600 * 1000))
            .signWith(key)
            .compact()
    }

    fun validateToken(jwt: String): Boolean {
        return try {
            Jwts.parserBuilder()
                .setSigningKey(key)
                .build()
                .parseClaimsJws(jwt)
            true
        } catch (e: Exception) {
            false
        }
    }

    fun getUsernameFromToken(jwt: String): String? {
        val claims: Claims = Jwts.parserBuilder()
            .setSigningKey(key)
            .build()
            .parseClaimsJws(jwt)
            .body
        return claims.subject
    }
}
```

- validateToken: 토큰이 유효하면 true, 아니면 false 반환
- getUsernameFromToken: 토큰에서 subject(보통 username)를 추출

위 코드에서 secretKey는 반드시 32byte(256bit) 이상이어야 하며, 실제 서비스에서는 환경변수 등에서 안전하게 관리해야 합니다.

궁금한 점 있으면 추가로 질문해주세요!

---


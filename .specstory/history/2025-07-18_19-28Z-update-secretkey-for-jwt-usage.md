<!-- Generated by SpecStory -->

# Update secretKey for JWT usage (2025-07-18 19:28Z)

_**User**_

secretKey를 임의로 만들어서 채워놓고
해당 secretKey를 사용하도록 모두 수정해줘

---

_**Assistant**_

네, 요청하신 대로 `secretKey`를 임의의 32바이트 이상 문자열로 생성해서 코드에 반영하고, JWT 발급 및 검증 시 해당 키를 일관되게 사용하도록 코드를 수정하겠습니다.

변경 사항 요약:
- `secretKey`를 임의의 32바이트 이상 문자열로 지정
- JWT 발급 시 `signingKey`를 별도로 만들지 않고, 이미 선언된 `key`를 사용
- 검증 및 username 추출 시도 동일하게 `key` 사용

바로 수정하겠습니다.

---

```diff
  @Service
  class JwtTokenProvider {
-     // TODO: key 발급 및 환경 변수 적용
-     private val secretKey = "your-256-bit-secret-your-256-bit-secret" // 32byte 이상 필요
+     // 32byte 이상의 임의의 시크릿 키 (예시)
+     private val secretKey = "d8f3b2c1e4a7f6b9c2d1e8f7a6b5c4d3d8f3b2c1e4a7f6b9c2d1e8f7a6b5c4d3" // 64byte
      private val key = Keys.hmacShaKeyFor(secretKey.toByteArray())
  
      // TODO: JWT 발급 / 재발급 ?
      fun issueToken(subject: String): String {
-         // TODO: get private key from environment
-         val signingKey =
-             Jwts.SIG.HS256
-                 .key()
-                 .build()
- 
-         // TODO: issue token
+         // signWith에 이미 선언된 key 사용
          val jwt =
              Jwts
```

```diff
                  .add("ian")
                  .and()
-                 .signWith(signingKey, Jwts.SIG.HS256)
+                 .signWith(key, Jwts.SIG.HS256)
                  .compact()
  
```

```diff
                  .parser()
                  .verifyWith(key)
- 
+                 .build()
+                 .parseSignedClaims(jwt)
              return true
          } catch (e: Exception) {
```

---

수정 완료했습니다.

- secretKey를 64바이트 임의 문자열로 지정했습니다.
- JWT 발급, 검증, username 추출 모두 해당 key를 일관되게 사용하도록 변경했습니다.

추가로 궁금한 점이나 더 필요한 작업이 있으면 말씀해 주세요!

---


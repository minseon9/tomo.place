<!-- Generated by SpecStory -->

# 전략 패턴의 적합성 검토 (2025-07-25 16:27Z)

_**User**_

1. Application Layer에서 정의하는 request를 Domain Layer까지 사용하는 건 문제가 돼. 명확하게 분리해야해.
2. Domain Layer에서도 Application Layer와 동일하게 Command를 분리하면 전략패턴이나 factory 패턴을 사용하는게 의미가 없어. 

이런 문제가 있는데,
전략 패턴을 사용함에 따라 생기는 문제라는 생각이 들어.

어떻게 생각하니?
전략패턴이 이 상황에서 최선인 지 파악해줘.
최선이라면, 위에 문제 사항에 대해서 개선해야해.

---

_**Assistant**_

<think><details><summary>Thought Process</summary>사용자가 제기한 문제들을 정리해보자:

1. Application Layer의 request가 Domain Layer까지 사용되고 있음 - 이는 DDD/Clean Architecture의 의존성 규칙을 위반하는 것
2. Domain Layer에서도 Application Layer와 동일하게 Command를 분리하면 전략패턴/factory 패턴의 의미가 없어짐

현재 코드를 보면:
- AuthApplicationService에서 AuthenticationRequest를 받음
- AuthenticationStrategy에서 AuthenticationCommand를 사용
- EmailPasswordAuthenticationStrategy와 OAuthAuthenticationStrategy가 각각 EmailPasswordAuthCommand, OAuthAuthCommand를 받음

문제점:
1. Application Layer의 request가 Domain까지 흘러가는 것은 맞지 않음
2. 전략패턴을 사용하는데 각 Command가 너무 세분화되어 있어서 전략의 의미가 퇴색됨

한국어로 응답해야 하므로 한국어로 작성하자.

먼저 현재 상황을 파악하기 위해 관련 파일들을 더 살펴봐야겠다.</details></think>

---

말씀하신 문제점들이 정확합니다. 현재 구조를 분석해보고 개선 방안을 제시하겠습니다.

먼저 현재 상황을 파악하기 위해 관련 파일들을 살펴보겠습니다.

---

Read file: tomo/user/src/main/kotlin/place/tomo/application/requests/AuthenticateRequest.kt

---

Read file: tomo/user/src/main/kotlin/place/tomo/application/commands/AuthenticationCommands.kt

---

Read file: tomo/user/src/main/kotlin/place/tomo/domain/commands/AuthenticationCommands.kt

---

<think><details><summary>Thought Process</summary>현재 구조를 이해했다:

1. Application Layer:
   - AuthenticationRequest (sealed class) with EmailPasswordAuthRequest, OAuthAuthRequest
   - AuthenticationCommand (sealed class) with EmailPasswordAuthCommand, OAuthAuthCommand

2. Domain Layer:
   - LinkSocialAccountCommand (별도)

3. Strategy Pattern:
   - AuthenticationStrategy<T : AuthenticationCommand>
   - EmailPasswordAuthenticationStrategy: AuthenticationStrategy<EmailPasswordAuthCommand>
   - OAuthAuthenticationStrategy: AuthenticationStrategy<OAuthAuthCommand>

문제점 분석:
1. Application Layer의 Request와 Command가 거의 동일한 구조로 중복
2. Strategy Pattern에서 각 전략이 서로 다른 Command 타입을 받아서 공통 인터페이스의 의미가 퇴색
3. Domain Layer에서 Application Layer의 Command를 사용하는 것은 의존성 역전 원칙 위반

개선 방안:
1. Strategy Pattern 대신 Factory Pattern이나 다른 패턴 사용 고려
2. Domain Layer에서는 공통 인터페이스를 사용하되, 내부적으로 타입 체크
3. 아니면 Strategy Pattern을 제거하고 각각을 독립적인 서비스로 분리

어떤 방식이 좋을까? 

옵션 1: Strategy Pattern 유지하되 공통 Command 사용
- AuthenticationCommand를 공통으로 사용하고, 내부에서 타입 체크
- 하지만 이렇게 되면 타입 안전성이 떨어짐
</details></think>

---

현재 코드 구조를 분석한 결과, 말씀하신 문제점들이 명확히 드러나고 있습니다.

## 현재 구조의 문제점

1. **의존성 규칙 위반**: Application Layer의 `AuthenticationCommand`가 Domain Layer까지 사용되고 있음
2. **전략패턴의 의미 퇴색**: 각 전략이 서로 다른 Command 타입을 받아서 공통 인터페이스의 장점이 사라짐
3. **중복 구조**: `AuthenticationRequest`와 `AuthenticationCommand`가 거의 동일한 구조

## 전략패턴에 대한 평가

현재 상황에서 **전략패턴은 과도한 설계**라고 판단됩니다. 이유는:

1. **타입이 너무 세분화**되어 전략의 공통성이 없음
2. **각 인증 방식이 완전히 다른 로직**을 가지므로 공통 추상화의 이점이 적음
3. **코드 복잡성만 증가**시키고 있음

## 개선 방안 제안

세 가지 옵션을 제시하겠습니다:

### 옵션 1: 전략패턴 제거 + 독립 서비스 분리
```kotlin
// Domain Layer에서 각각 독립적인 서비스로 분리
@Service
class EmailPasswordAuthenticationService

@Service  
class OAuthAuthenticationService

// Application Layer에서 직접 호출
class AuthApplicationService {
    fun authenticate(request: AuthenticationRequest): String = when(request) {
        is EmailPasswordAuthRequest -> emailPasswordService.authenticate(request.email, request.password)
        is OAuthAuthRequest -> oAuthService.authenticate(request.provider, request.authorizationCode)
    }
}
```

### 옵션 2: Factory Pattern 사용
```kotlin
// Domain에서 Factory로 적절한 서비스 반환
class AuthenticationServiceFactory {
    fun getService(type: AuthenticationType): AuthenticationService
}
```

### 옵션 3: 단일 공통 Command 사용
```kotlin
// 공통 AuthenticationContext 사용
data class AuthenticationContext(
    val type: AuthenticationType,
    val credentials: Map<String, Any>
)
```

어떤 방향으로 개선하는 것이 좋을까요? 각 옵션의 장단점을 설명해드릴 수도 있습니다.

---

